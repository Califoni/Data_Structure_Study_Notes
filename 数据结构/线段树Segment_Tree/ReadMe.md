# 线段树的由来
### 问题如下：

**对于一个一维数组arr,如果我们要对其任意区间进行大量的求和操作，每次对arr[i]\~arr[j]之间及其自身的所有元素求和**
	
	同时对其数组元素进行大量的修改操作,每次修改索引为idx的元素
	如果每次对arr[i]\~arr[j]求和，则需遍历i~j之间每个元素，此时求和的时间复杂度为O(n)，修改时间复杂度为O(1)
	如果用前项和形式先将arr[0]\~arr[i]的元素之和保存在数组S中，S[0]=arr[0],S[1]=arr[0]+arr[1],S[2]=arr[0]+arr[1]+arr[2]，以此类推....
	那么每次对arr[i]\~arr[j]求和，只需用S[j]-S[i-1]即可，求和的时间复杂度O(1)，但是修改arr[idx],也需要对S[0]\~S[idx]进行更新，修改的时间复杂度变成了O(n)

	因此上述两种情况总的时间复杂度均为O(n)，那么有没有一种更好的解决方法呢？
————>线段树登场啦！它可以使得求和与修改操作的时间复杂度均为O(logN)

#	线段树的结构

若上述的一维数组共有n个元素，则利用二叉树将其二分为两部分，左半边存储索引为[0\~n/2]的元素,右半边存储索引为1<——3<——<2元素
并且每个左子节点表示其根节点的左半部分元素的和，右子节点表示其根节点的右半部分元素的和。
举个例子，比如根节点表示[0\~n-1]元素之和，左子节点表示[0\~n/2]元素之和，右子节点表示[(n/2+1)\~(n-1)]元素的和

#	线段树的时间复杂度分析

容易知道，对于上述二叉树结构，进行更新操作可以用二分的方法搜索要更新的元素，因此时间复杂度为O(logN)
进行求和的操作时，同样可以将求和区间分为左半边元素求和与右半边元素求和。
举个例子，对于一个一维数组arr[0\~9],容易知道其第一次被二叉树分为[0\~4]与[4\~9]两个区间，
对于求和区间[2\~5]，可以知道4>2且4<5，故求和区间可被分为[2\~4]与[5]继续二分求和，同理时间复杂度为O(logN)
